---
# Every document starts with a front matter in YAML enclosed by triple dashes.
# See https://jekyllrb.com/docs/front-matter/ to learn more about this concept.
caip: CAIP-261
title: Web of Trust primitive
author: Dayan | dayan.fc | dayan.lens | dayanb.eth | (@dayksx) <dayksx@protonmail.com>
status: Draft
type: Standard
created: 2023-11-21
updated: 2023-11-21
---

## Simple Summary

CAIP-261 introduces a data framework to represent trust assertions among peers, facilitating the development of a global web of trust.

## Abstract

A web of trust establishes peer-to-peer trust graphs through trust and/or distrust assertions among peers, offering the possibility to extract valuable insights such as relative reputation score by using graph theory.

This proposal outlines a comprehensive data framework designed to facilitate the representation, management and verification of explicit trust assertions for peers within a decentralized environment.

The proposed data framework is designed to be flexible, extensible, and scalable, ensuring compatibility across any decentralized network and facilitating a wide range of reputation based use-cases.

By establishing a common language for peer trust assertions, CAIP-261 enables diverse ecosystems to interoperate with a shared understanding of trust, benefiting from each other and creating synergies that strengthen trust insights.

## Specification

### Trust Representation

#### Identifier Scheme

Trust assertions are made about, and by, peers identifiable through any form of public key derivatives, effectively bound to their owners.

Identification of peers SHOULD be done with [Decentralized Identifiers][DID] for interoperabiltiy, preferably those based on cryptographic keys for autonomy.

- **DID:PKH (Public Key Hash):** This method is designed to be chain-agnostic, allowing for the creation of DIDs based on public key hashes from various blockchains (e.g., Ethereum, Bitcoin, Solana). This universality facilitates interoperability and simplifies identity management across different ecosystems.
- **DID:Key:** This method generates DIDs directly from a variety of cryptographic public keys, supporting multiple key types (e.g., Ed25519, RSA). This method is straightforward and self-contained, requiring no interaction with blockchain networks, which makes it fast and cost-effective for operations that don't need decentralized verification.
- **DID:web:** Though not directly tied to key pairs in the same way as others, DID:Web utilizes domain names to create DIDs, enabling organizations to leverage their existing domain infrastructure for identity purposes. This method bridges traditional web infrastructure with the decentralized identity ecosystem, enhancing trust and verifiability through well-known web standards.
- Blockhain tight DID such as DID:btcr, DID:ethr, DID:sol...

#### Data Model

All subsequent documents adhere to the [Verifiable Credential Data Model](https://www.w3.org/TR/vc-data-model/) for representation purposes.
However this standard does not prescribe any specific document type, even though internationally recognized standards can just be recommended.
The standard presumes that both the `issuer` property will be dereferenced and the complete contents of the `credentialSubject` will be consumed only after the wire-formats and signed-envelopes have been verified.

**Peer Trust Assertions:**

Modeling trust and distrust towards an individual or entity can be a complex task due to the subjective and multifaceted nature of trust.
This standard proposes the following conceptualization for the trust concept:

- `scope`: This defines the applicable trust perimeter; `scope` should be a noun;
- `level`: This defines the extent of trust; `level` MUST remain within the following range: [-1,1]. This could be translated as follows: `Very low` (-1), `Low` (-0.5), `Neutral` (0), `High` (0.5), `Very High` (1);
- `reason` (optional): This defines the motivation of the trust according to some tagging system or other dictionary shared across producers and consumers; whether trust signals should be ignored or downweighted if they contain unknown entries in this array is an important design question for such systems.

The `scope` has reference values for interoperability purposes, but also need to be extendable to fit any use-case (cf. below [Scope of Trust Data Model](#scope-of-trust-data-model)).


**Assertions of trust to a peer:**
```json
"type": ["VerifiableCredential", "PeerTrustAssertion"],
"issuanceDate": "2024-02-15T07:05:56.273Z",
"issuer": "did:pkh:eip155:1:0x44dc4E3309B80eF7aBf41C7D0a68F0337a88F044",
"credentialSubject":
{
  "id": "did:pkh:eip155:1:0xfA045B2F2A25ad0B7365010eaf9AC2Dd9905895c",
  "trustworthiness":
  [
    {
      "scope": "Honesty",
      "level": 0.5,
      "reason": ["Alumnus"]
    },
    {
      "scope": "Software development",
      "level": 1,
      "reason": ["Software engineer", "Ethereum core developer"]
    },
    {
      "scope": "Software security",
      "level": 0.5,
      "reason": ["White Hat", "Smart Contract Auditor"]
    }
  ]
},
"proof": {}
```

**Assertion of distrust to a peer:**
```json
"type": ["VerifiableCredential", "TrustCredential"],
"issuanceDate": "2024-02-15T07:05:56.273Z",
"issuer": "did:pkh:eip155:1:0x44dc4E3309B80eF7aBf41C7D0a68F0337a88F044",
"credentialSubject":
{
  "id": "did:pkh:eip155:1:0xC3764761E297D6f121e79C32A65829Cd1dDb4D33",
  "trustworthiness":
  [
    {
      "scope": "Honesty",
      "level": -1
      "reason": ["Scam", "Rug pull"]
    },
    {
      "scope": "Data protection",
      "level": -1,
      "reason": ["Data monetization", "Data leak"]
    },
    {
      "scope": "Software security",
      "level": -0.5,
      "reason": ["Poor track record", "Lack of transparency"]
    },
    {
      "scope": "User experience design",
      "level": -0.5,
      "reason": ["Poor UX"]
    },
    {
      "scope": "Lawful",
      "level": -1,
      "reason": ["Money laundering", "Piracy", "Non-compliance"]
    }
  ]
},
"proof": {}
```

Standards based on the CAIP-261 can propose reference lists of "scope" to facilitate interoperability across different systems.
### Trust Management
Trust evolve over time, and have a full lifecycle, from creation, update, to revocation.

#### Trust storage
Peer Trust Assertions SHOULD be store in a data store that meet the following properties to guarantee censorship resistance

- Data availability: The datastore should make the assertions and proofs publicly available for consumption and verification purposes;
- Tamper-proof: The datastore should provide assertion data with proofs of completeness, ensuring that none have been altered or obstructed them;


#### Trust pause
Peer Trust Assertions SHOULD be updatable according the use case.

**Revocation of trust assertion:**
```json
"type": ["VerifiableCredential", "TrustCredential"],
"issuanceDate": "2024-02-29T14:31:56.273Z",
"issuer": "did:pkh:eip155:1:0x44dc4E3309B80eF7aBf41C7D0a68F0337a88F044",
"credentialStatus": {
    "id": "https://snaps.example/credentials/status/3#94567",
    "type": "BitstringStatusListEntry",
    "statusPurpose": "suspension",
    "statusListIndex": "94567",
    "statusListCredential": "https://snaps.example/credentials/status/3",
},
```
#### Trust revocation
Peer Trust Assertions SHOULD be revocable according the use case.

This consist of issuing a new assertion, pointing to the previous one as revoked.

**Revocation of trust assertion:**
```json
"type": ["VerifiableCredential", "TrustCredential"],
"issuanceDate": "2024-02-29T14:31:56.273Z",
"issuer": "did:pkh:eip155:1:0x44dc4E3309B80eF7aBf41C7D0a68F0337a88F044",
"credentialStatus": {
    "id": "https://snaps.example/credentials/status/3#94567",
    "type": "BitstringStatusListEntry",
    "statusPurpose": "revocation",
    "statusListIndex": "94567",
    "statusListCredential": "https://snaps.example/credentials/status/3",
},
```

### Trust assertion Verification

#### Signature verification

The veracity and integrity of trust assertions is fundamental to prevent biaises insights. 
Therefore all trust assertions SHOULD be cryptographically signed by the issuer, by strong cryptography.

- **ECDSA (Elliptic Curve Digital Signature Algorithm):** ECDSA is widely used across various blockchain platforms, including Ethereum. It offers a strong level of security with a shorter key length, making it efficient for on-chain transactions. ECDSA signatures are compact, which helps in keeping the transaction sizes and, consequently, the transaction fees lower.

- **EdDSA (Edwards-curve Digital Signature Algorithm):** EdDSA, and specifically its Ed25519 variant, is known for its high performance and security. It is designed to be faster and more secure against certain types of cryptographic attacks compared to other signature schemes. Ed25519 is suitable for systems requiring high-speed operations and robust security, making it an excellent choice for blockchain applications.

- **Schnorr Signatures:** Schnorr signatures offer several advantages, including non-malleability, linearity, and the ability to create multi-signatures. Although not as widely adopted as ECDSA in current blockchain platforms, Schnorr signatures are gaining attention for their potential to enhance privacy and efficiency, particularly in the context of Bitcoin and related technologies.

- **RSA (Rivest-Shamir-Adleman):** While RSA is not as commonly used in blockchain applications due to its larger key and signature sizes, it remains one of the most secure and widely trusted cryptographic algorithms. RSA might be considered for specific use cases where its extensive adoption and security track record are deemed beneficial, despite the higher computational and storage requirements.

EIP-712 should be considered a complementary cryptographic proof method alongside others like ECDSA, EdDSA, Schnorr, and RSA for on-chain verifiable credentials. Its inclusion emphasizes the importance of user-friendly, secure, and efficient interactions with blockchain-based identity and credential systems, particularly within the Ethereum ecosystem.
EIP-712 require to have all fields present, event if their value is empty.

```json
  "proof": {
      "verificationMethod": "did:pkh:eip155:59144:0x3892967AA898d7EeBf1B08d3E1F31B2F4C84317A#blockchainAccountId",
      "created": "2024-01-27T07:05:56.273Z",
      "proofPurpose": "assertionMethod",
      "type": "EthereumEip712Signature2021"
  }
```

#### Format verification
The assertions SHOULD respect the standard data structure in order to be validated.

#### Validity verification
The validity of assertions can depends on additional metadata:
- validity period (`validFrom`, `validUntil`), 
- status change (`revocation`, `suspension`).

## Rationale

### Using cryptographic keys for peers identity
These identifiers and keys are designed to be self-verifying, which means they can prove their authenticity independently without relying on a centralized registry or authority. 
This self-sufficiency not only enhances security by reducing potential points of failure and attack but also promotes privacy and user control. 
Individuals and entities can manage their identities and trust relationships directly, without intermediation, facilitating a more decentralized and resilient digital ecosystem.

[Decentralized identifiers][DID] using the `pkh` and `key` methods allow for the identification of account owners or trust computers in a chain-agnostic manner without the complexity of on-chain resolution.

### Using content identifier for assertions
[Content Identifiers][CID] enable anyone to deterministically generate identifiers based on the canonicalized content of a given JSON document, and store it in a compact, tamper-evident way conducive to merging, syncing, or even CRDT patterns.

### Agnostic data model
- Flexible data ranges leveraging floats type facilitating the creation of tailored user experiences,
- Data structures has been designed to be use-case agnostic, enabling the reusability of the data across different use-cases.


### Trust modeling

1. Trust in an individual or entity is based on their qualities, or their abilities; it is not binary and evolves over time,
2. Distrust assertions allow for the capture of suspicious behaviors,


## Privacy Considerations
Issuing assertions makes public the opinion of issuers (identified by their public address), and therefore should be informed about the consequence of their action.

## References
<!--Links to external resources that help understanding the CAIP better. This can e.g. be links to existing implementations. See CONTRIBUTING.md#style-guide . -->

- [CAIP-1][CAIP-1] defines the CAIP document structure

[CAIP-1]: https://ChainAgnostic.org/CAIPs/caip-1
[DID]: https://www.w3.org/TR/did-core/
[CID]: https://github.com/multiformats/cid
[did:pkh]: https://github.com/w3c-ccg/did-pkh/blob/main/did-pkh-method-draft.md
[multihash]: https://github.com/multiformats/multihash
[multicodec-json]: https://github.com/multiformats/multicodec/blob/master/table.csv#L138
[JCS]: <https://www.rfc-editor.org/rfc/rfc8785>

## Copyright

Copyright and related rights waived via [CC0](../LICENSE).